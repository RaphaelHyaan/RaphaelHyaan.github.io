<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>机器人课程报告 | Raphael's Home</title><meta name="author" content="Raphael Hyaan"><meta name="copyright" content="Raphael Hyaan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="机器人课程报告 背景介绍 在本次报告中可以被介绍一种用于武器的炮塔装置的建模。 机械臂在武器中应用较广，主要用于提高武器的稳定性和精准度。例如，在炮塔装置中，机械臂可以帮助精准地瞄准目标，并保持炮塔在移动过程中的稳定。此外，机械臂还可以用于自动装弹，提高射击效率。 对于用于射击的机械臂，例如教材中提及的有人操作的机械装置，其主要作用是快速辅助瞄准。本报告参考描述了一种基于地面的用于射击的模">
<meta property="og:type" content="article">
<meta property="og:title" content="机器人课程报告">
<meta property="og:url" content="http://raphaelhyaan.cn/2023/11/08/others/robot-1/index.html">
<meta property="og:site_name" content="Raphael&#39;s Home">
<meta property="og:description" content="机器人课程报告 背景介绍 在本次报告中可以被介绍一种用于武器的炮塔装置的建模。 机械臂在武器中应用较广，主要用于提高武器的稳定性和精准度。例如，在炮塔装置中，机械臂可以帮助精准地瞄准目标，并保持炮塔在移动过程中的稳定。此外，机械臂还可以用于自动装弹，提高射击效率。 对于用于射击的机械臂，例如教材中提及的有人操作的机械装置，其主要作用是快速辅助瞄准。本报告参考描述了一种基于地面的用于射击的模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fstructure.png">
<meta property="article:published_time" content="2023-11-08T13:38:31.000Z">
<meta property="article:modified_time" content="2024-04-08T13:38:38.000Z">
<meta property="article:author" content="Raphael Hyaan">
<meta property="article:tag" content="零散笔记">
<meta property="article:tag" content="机器人">
<meta property="article:tag" content="大作业">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fstructure.png"><link rel="shortcut icon" href="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Flana cat 002.png"><link rel="canonical" href="http://raphaelhyaan.cn/2023/11/08/others/robot-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '机器人课程报告',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-08 21:38:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/butterflyChange/css/code.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2FR-2.png" onerror="onerror=null;src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffriend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Reading/"><i class="fa-fw fas fa-book"></i><span> Reading</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/Video/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fstructure.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Raphael's Home"><span class="site-name">Raphael's Home</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Reading/"><i class="fa-fw fas fa-book"></i><span> Reading</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/Video/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">机器人课程报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-08T13:38:31.000Z" title="发表于 2023-11-08 21:38:31">2023-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-08T13:38:38.000Z" title="更新于 2024-04-08 21:38:38">2024-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/">零散笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="机器人课程报告"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="机器人课程报告">机器人课程报告</h1>
<h1 id="背景介绍">背景介绍</h1>
<p>在本次报告中可以被介绍一种用于武器的炮塔装置的建模。</p>
<p>机械臂在武器中应用较广，主要用于提高武器的稳定性和精准度。例如，在炮塔装置中，机械臂可以帮助精准地瞄准目标，并保持炮塔在移动过程中的稳定。此外，机械臂还可以用于自动装弹，提高射击效率。</p>
<p>对于用于射击的机械臂，例如教材中提及的有人操作的机械装置，其主要作用是快速辅助瞄准。本报告参考描述了一种基于地面的用于射击的模型。这种模型可以对一个确定的方向提供不错的打击能力。且配合汽车的移动或者类似于雷达车那样的平面转动方法，可以转换打击的方向。另外，这个模型具有不错的扩展性，现在的模型是一个近似串联的模型，而在实际应用时，可以通过增加机械臂数量的方式提供更强力的打击。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_1.png" /></p>
<p>在本报告中，会对这种模型应用Denavit-Hartenberg的描述方法进一步简化，并分析其移动性，运动学，反运动学，和动力学。</p>
<h1 id="模型建立">模型建立</h1>
<p>这篇报告中介绍的模型如下图所示，它具有6个自由度。在这6个自由度中，其中的4个自由度有转动副提供。其中，三个转动副的轴在同一平面，y轴（或x轴，在不同的计算中可能会有不同地约定方式）始终穿过这个平面，另一个转动副则以y轴为转轴，来控制这个平面的角度。另外两个自由度有滑动副来提供。</p>
<h3 id="模型的描述">模型的描述</h3>
<p>基座是一个树立于xz平面的薄板，其上通过螺丝，连接两个固定的竖杆。竖杆和薄板共同构成真正的基座。为了方便运算，并没有将薄板假设为一个与现实中类似用于的模型相同的大小，而是缩小至1500*1000mm。在后续的计算中，这些尺寸将进一步缩小，以方便计算。</p>
<p>由于竖杆的限制，并非全部的薄板的空间都是可用的。第一个连杆是可以在两个竖杆之间滑动的横杆。横杆可以在竖杆提供的长600mm的凹槽中，沿x轴方向滑动。在建模时，并没有使用滑槽约束，而是通过基础约束：要求两个面的平行以及设定运动范围实现。这提供了第一个自由度。</p>
<p>第二个连杆是套在横杆上，沿z轴方向滑动的底座。这个基座相比于其他的部件非常小，这些构建构成了一个双自由的的直角坐标型操作臂。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_2.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_3.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_4.png" /></p>
<p>如下图所示，基座的下半部分是一个带空腔的方块，其尺寸与横杆严格匹配，在实际应用过程中，可能需要进一步处理，以满足其滑动的性质。而其上半部分是一个用以满足旋转特性的空心圆柱。这将于第一个连杆结合，构成双自由度基础上的机械臂结构的基座。具体的连接方式可以在上图中透明的连杆中看到。当然，他们并非简单的直接连接，在连杆内部存在一个凸起用来卡住底座。这在现实中似乎是无法生产的，但通过其他方式也可以实现。</p>
<p>经由这种设置，第一个连杆可以在基座上旋转，构成第三个自由度。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_5.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_6.png" /></p>
<p>一个三个转动副垂直与同一平面的连杆被安装于竖杆上，其中最后一个转动副为腕关节。用于操控模型中建模较为粗糙的执行元件。他们可以在到达他们所在面的几乎所有位置。但是，在这个过程中，连杆的交叉和重叠并没有被很好的考虑。这是这个模型所欠缺的。</p>
<p>这个模型可以在补充材料中找到。</p>
<h2 id="模型简化">模型简化</h2>
<p>一般而言，从solidwork导出为urdf文件已经经过很多尝试。其中，"sw2urdf"和"SolidWorks
to URDF
Exporter"都是SolidWorks插件，用于将SolidWorks模型导出为URDF文件。根据他们的极少，它们都提供了简化和自动化的工作流程，使用户能够轻松地将SolidWorks设计转换为URDF格式，以便在机器人相关应用程序中使用。其中，"sw2urdf"插件是ROS（Robot
Operating
System）社区开发的SolidWorks插件。据称，它提供了一个简单的界面，使用户能够直接从SolidWorks中导出URDF文件。并支持SolidWorks中的关节定义、连接关系和惯性属性的导出。它还提供了一些高级功能，如传感器支持和碰撞检测设置。而"SolidWorks
to URDF
Exporter"插件是由第三方开发的SolidWorks插件。它允许用户将SolidWorks模型导出为URDF文件，并提供了一些自定义选项。插件支持导出关节类型、连接关系、惯性属性和传感器等信息。它还提供了一些额外的功能，如导出模型的CAD几何信息和可视化模型的渲染。</p>
<p>然而，经过我长时间的尝试，一致不能将此模型完全导入python或者matlab的机器人工具箱，再导入过程中，会出现部分约束的失效。同时，这些软件都依赖于坐标系下约束信息的转换，经过大约四个小时的尝试，最终决定在python中重新建模。</p>
<h3 id="robotics-toolbox-for-python-rtb">Robotics Toolbox for Python
(rtb)</h3>
<p>Robotics Toolbox for
Python，即Python的机器人工具箱，是一款用于研究和教学的开源软件。它与matlab的相应工具箱是同一个作者开发。它包含了一系列用于模拟和分析机器人系统的函数和类。这些工具可以用于机器人的运动学分析、路径规划、视觉处理等多方面。</p>
<p>其中，<code>**DHRobot**</code> 是 Python
机器人工具箱中的一个重要类，用于处理基于
Denavit-Hartenberg（D-H）参数的机器人模型。D-H
参数是一种常用的机器人连杆描述方法，能够通过四个参数来定义连杆之间的几何关系。</p>
<p><code>dhrobot</code> 类提供了一系列方法来处理基于 D-H
参数的机器人模型，如：</p>
<ul>
<li><code>fkine()</code>：正向运动学计算。输入为关节参数，输出为末端执行器的位姿。</li>
<li><code>ikine()</code>：逆向运动学计算。输入为末端执行器的位姿，输出为关节参数。</li>
<li><code>jacob0()</code> 和
<code>jacobn()</code>：计算机器人的雅可比矩阵，用于描述关节速度与末端执行器线速度和角速度之间的关系。</li>
<li><code>plot()</code>：绘制机器人模型。</li>
</ul>
<p>这些方法使得 <code>**DHr**obot</code>
成为了机器人运动学分析和控制的有力工具。</p>
<p>相比于matlab的相应工具，python的工具箱并不完善。事实上，其文档中存在大量错误，导致很多功能并不能如文档提到的使用方式。尽管如此，相比于Matlab的机器人工具箱，Robotics
Toolbox for Python
的优势足以在小规模使用的时候，成为最优解。首先Robotics Toolbox for
Python
是完全开源的。这一点对于学习和研究者来说非常有利。事实上，我在实际应用过程中，也对工具箱中的部分实现方法进行了修改。这在matlab中是不能实现的。此外，良好的社区支持使Python拥有庞大的开发者社区，这意味着当遇到问题时，可以很容易地找到解决方案或者获得帮助。而Matlab的社区相对较小。</p>
<h3 id="模型简化-1">模型简化</h3>
<p>为了方便建模和未来的进一步分析，我撇弃了这个模型中不必要的所有信息，仅保留了建立串联模型的必要数据。在简化后，我基于Denavit-Hartenberg方法，重新建立模型。为了方便之后的计算和分析，将这个模型简化为<strong>串联模型</strong>。使用两个简单的滑动副来代替，其结构如下：</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_7.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_8.png" /></p>
<ul>
<li>必须要注意的是左图中，从第三个关节有一个<span
class="math inline">\(\pi/2\)</span>的扭转，也就是<span
class="math inline">\(x_2 \ x_3\)</span>并非有着相同的方向。</li>
</ul>
<p>相比于一般的Denavit-Hartenberg方法，我选择了改进的Denavit-Hartenberg方法。事实上，这也是教材所提供和推荐的方法。</p>
<p>改进的Denavit-Hartenberg方法是一种常用于解析机器人运动学的方法。它通过建立每个关节的坐标系和定义四个参数（连接长度、连接偏转、连接角、关节偏转）来描述从一个关节到下一个关节的变换。这四个参数也被称为Denavit-Hartenberg参数。</p>
<p>在改进的Denavit-Hartenberg方法中，坐标系的选择有所不同。在原始的Denavit-Hartenberg方法中，坐标系是沿着关节轴线和连接线选择的。然而，在改进的方法中，坐标系是沿着关节轴线和垂直于两个关节轴线的平面选择的。这种改变使得坐标系的选择更为直观，也使得参数的计算更为简单。</p>
<p>此外，改进的Denavit-Hartenberg方法还引入了一个新的概念——连杆坐标系。这种坐标系定义在连杆的一端，使得描述连杆的运动变得更加简单。这种方法对于分析具有复杂运动的机器人系统非常有用。</p>
<p>在这个模型的基础上基于改进的Denavit-Hartenberg方法分析：</p>
<ul>
<li>首先找出各关节的轴线。由于我们的所有关节都是滑动副或者转动副，其轴线方向非常容易判断。如上图蓝色线条所在直线即为各关节轴线。需要注意的是，从第三个关节开始，使用的基坐标系与前两个并不相同。这导致第三个关节引入了一个额外的扭转。可以对比两幅图片来得到。</li>
<li>找到关节轴之间的公垂线或者关节轴之间的交点，用来确认原点位置和确认z轴的指向，这些信息已在上图中标出。</li>
<li>使x轴沿公垂线指向，已使用红线在上图中标出。</li>
<li>分析其连杆参数：</li>
</ul>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(a_i\)</span></th>
<th><span class="math inline">\(\alpha_i\)</span></th>
<th><span class="math inline">\(d_i\)</span></th>
<th><span class="math inline">\(\theta_i\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\(0\)</span></td>
<td>0</td>
<td><span class="math inline">\(offset\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>2</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(\pi/2\)</span></td>
<td><span class="math inline">\(offset\)</span></td>
<td><span class="math inline">\(\pi/2\)</span></td>
</tr>
<tr class="odd">
<td>3</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(-\pi/2\)</span></td>
<td><span class="math inline">\(10\)</span></td>
<td><span class="math inline">\(offset\)</span></td>
</tr>
<tr class="even">
<td>4</td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(offset\)</span></td>
</tr>
<tr class="odd">
<td>5</td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(offset\)</span></td>
</tr>
<tr class="even">
<td>6</td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(\pi/4\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(offset\)</span></td>
</tr>
</tbody>
</table>
<p>根据分析得到的连杆信息，在python中建模得到上图，这证明了分析的正确性。</p>
<h1 id="运动学分析">运动学分析</h1>
<h2 id="运动学分析-1">运动学分析</h2>
<p>运动学分析主要研究的是机器人的运动特性，而不涉及力和力矩等因素。运动学可以分为正向运动学和逆向运动学两部分。这里我们主要介绍正向运动学分析，或者说前向运动学分析。正向运动学分析是根据机器人的关节参数确定其末端执行器位置和姿态的过程。简单来说，就是通过机器人的关节角度来计算机器人手臂的位置和方向。这是机器人导航、路径规划以及进行精确操作所必需的。正向运动学的历史可以追溯到20世纪50年代，当时人们开始研究如何使用计算机来控制机器人的运动。这一研究领域的发展推动了工业机器人的普及以及自动化生产的发展。</p>
<p>基于这些介绍，我们进行运动学分析，首先，我们使用变换矩阵计算一个简单的模型。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_9.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_10.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_11.png" /></p>
<p>首先从基坐标系到第一个坐标系，第一个关节是一个滑动副，只有沿轴向的平移。在DH方法中，<span
class="math inline">\(z\)</span>轴是轴向方向，因此，易得第一个变换矩阵：</p>
<p><span class="math display">\[
T_0^1 = \left(\begin{array}{cccc}1&amp; 0&amp;
0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;20\\0&amp;0&amp;0&amp;1\end{array}\right)
\]</span></p>
<p>第二个关节也是平移，由于两个杆的轴向方向并不相同，因此涉及到坐标系的旋转。新的z轴方向应该指向y轴负方向，因此也是第一个坐标系的y轴负方向。同时，x轴指向原本的z轴方向（注意这里跟之前的DH推到的x轴方向的并不相同），因为基坐标系做了调整。根据预设，应该沿新的z轴方向平移10的距离，得到第二个转换矩阵：</p>
<p><span class="math display">\[
T_1^2 = \left(\begin{array}{cccc}0&amp; -1&amp;
0&amp;0\\0&amp;0&amp;-1&amp;-10\\1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{array}\right)
\]</span></p>
<p>第三个关节是一个绕原本的y轴旋转的关节。在预设中，设定其旋转<span
class="math inline">\(\pi/4\)</span>。同时，两个坐标系在y轴上相聚10个单位长度。用相同的方法得到新的转换矩阵：</p>
<p><span class="math display">\[
T_2^3 =
\left(\begin{array}{cccc}   &amp;0.7071        &amp;-0.7071         &amp;0         &amp;0\\
   &amp;0         &amp;0        &amp;1        &amp;10\\
   &amp;-0.7071         &amp;-0.7071         &amp;0         &amp;0\\
   &amp;0         &amp;0         &amp;0         &amp;1\end{array}\right)
\]</span></p>
<p>第四个关节是一个转动副。有<span
class="math inline">\(-\pi/4\)</span>的旋转预设，同时在x轴上有5个单位长度的距离。得到新的矩阵：</p>
<p><span class="math display">\[
T_3^4 =
\left(\begin{array}{cccc}     &amp;0.7071   &amp;-0.7071    &amp;0         &amp;5\\
   &amp;0         &amp;0        &amp;-1         &amp;0\\
   &amp;0.7071    &amp;0.7071    &amp;0         &amp;0\\
   &amp;0         &amp;0         &amp;0         &amp;1
\end{array}\right)
\]</span></p>
<p>第五个关节和第六个关节都是转动副，其本身与第四个关节相似，因此不设计新的预设增加计算复杂度。在这种情况下，新的两个转换矩阵为：</p>
<p><span class="math display">\[
T_4^5 =
\left(\begin{array}{cccc}        &amp;0        &amp;-1         &amp;0         &amp;5\\      
   &amp;1         &amp;0         &amp;0         &amp;0\\      
   &amp;0         &amp;0         &amp;1         &amp;0\\      
   &amp;0         &amp;0         &amp;0         &amp;1  \end{array}\right)\
T_5^6 =
\left(\begin{array}{cccc}        &amp;1        &amp;0         &amp;0         &amp;5\\      
   &amp;0        &amp;1         &amp;0         &amp;0\\      
   &amp;0         &amp;0         &amp;1         &amp;0\\      
   &amp;0         &amp;0         &amp;0         &amp;1  \end{array}\right)
\]</span></p>
<p>最后将这些矩阵相乘，为了加快计算速度，使用numpy这种c语言风格的计算方式，得到：</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_12.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_13.png" /></p>
<p>使用python的roboticstoolbox工具箱计算该机械臂的运动学，分别使用A(
)方法和fkine( )方法，得到相同的结果：</p>
<p><span class="math display">\[
\begin{pmatrix}-0.7071 &amp; 0.7071 &amp; 0 &amp; -17.07 \\-0.5 &amp;
-0.5 &amp; -0.7071 &amp; -6.464 \\-0.5 &amp; -0.5 &amp; 0.7071 &amp;
23.54 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}
\]</span></p>
<h1 id="操作臂子空间描述">操作臂子空间描述</h1>
<blockquote>
<p>为了我方便计算，我们认为元件3固定，前两个平移关节的关键参数分别设置为[20,10]，我们只考虑后四个关节。</p>
</blockquote>
<p>操作臂子空间，通常被称为工作空间，指的是机器人操作臂在所有可能的关节配置下能够到达的空间区域。这个空间是由操作臂末端执行器（例如，夹具或工具）在物理空间中的所有可能位置和方向构成的。操作臂子空间的大小和形状取决于机器人的几何结构，包括关节的数量，类型（旋转或平移）以及它们的排列方式。</p>
<h3 id="子空间的符号表示">子空间的符号表示</h3>
<p>我们分别使用<span
class="math inline">\(\alpha,\beta,\gamma,\epsilon\)</span>个符号表示后四个关节的角度，并由此计算子空间。为了方便符号计算，我们在列出符号矩阵之后，使用matlab的符号计算而不是python的符号计算。这是因为matlab的符号计算效率远高于python。</p>
<p><span class="math display">\[
\begin{aligned}
&amp; T_2^3  =
&amp; \left(\begin{array}{cccc}
\cos (\alpha) &amp; -\sin (\alpha) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 10 \\
-\sin (\alpha) &amp; -\cos (\alpha) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}&amp; T_3^4= &amp; \left(\begin{array}{cccc}-\sin (\beta)
&amp; -\cos (\beta) &amp; 0 &amp; 5 \\0 &amp; 0 &amp; -1 &amp; 0 \\\cos
(\beta) &amp; -\sin (\beta) &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp;
1\end{array}\right)\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}&amp; T_4^5= &amp; \left(\begin{array}{cccc}-\sin
(\gamma) &amp; -\cos (\gamma) &amp; 0 &amp; 5 \\\cos (\gamma) &amp;
-\sin (\gamma) &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0
&amp; 0 &amp; 1\end{array}\right)\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}&amp; T_5^6 =&amp; \left(\begin{array}{cccc}\cos
(\varepsilon) &amp; -\sin (\varepsilon) &amp; 0 &amp; 5 \\\sin
(\varepsilon) &amp; \cos (\varepsilon) &amp; 0 &amp; 0 \\0 &amp; 0 &amp;
1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)\end{aligned}
\]</span></p>
<p>求死者的乘积得到子空间矩阵：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; T_2^6 =\text { ( } \\
&amp; \left(\begin{array}{cccc}
\sin (\varepsilon) \sigma_4-\cos (\varepsilon) \sigma_3 &amp; \cos
(\varepsilon) \sigma_4+\sin (\varepsilon) \sigma_3 &amp; \sin (\alpha)
&amp; 5 \cos (\alpha)-5 \cos (\alpha) \sin (\beta)-5 \cos (\alpha) \cos
(\beta) \cos (\gamma)+5 \cos (\alpha) \sin (\beta) \sin (\gamma) \\
\sin (\varepsilon) \sigma_5-\cos (\varepsilon) \sigma_6 &amp; \cos
(\varepsilon) \sigma_5+\sin (\varepsilon) \sigma_6 &amp; 0 &amp; 5 \cos
(\beta)-5 \cos (\beta) \sin (\gamma)-5 \cos (\gamma) \sin (\beta)+10 \\
\cos (\varepsilon) \sigma_1-\sin (\varepsilon) \sigma_2 &amp; -\cos
(\varepsilon) \sigma_2-\sin (\varepsilon) \sigma_1 &amp; \cos (\alpha)
&amp; 5 \sin (\alpha) \sin (\beta)-5 \sin (\alpha)+5 \cos (\beta) \cos
(\gamma) \sin (\alpha)-5 \sin (\alpha) \sin (\beta) \sin (\gamma) \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
avec\quad\begin{aligned}&amp; \sigma_1=\cos (\beta) \cos (\gamma) \sin
(\alpha)-\sin (\alpha) \sin (\beta) \sin (\gamma) \\&amp; \sigma_2=\cos
(\beta) \sin (\alpha) \sin (\gamma)+\cos (\gamma) \sin (\alpha) \sin
(\beta) \\&amp; \sigma_3=\cos (\alpha) \cos (\beta) \cos (\gamma)-\cos
(\alpha) \sin (\beta) \sin (\gamma) \\&amp; \sigma_4=\cos (\alpha) \cos
(\beta) \sin (\gamma)+\cos (\alpha) \cos (\gamma) \sin (\beta) \\&amp;
\sigma_5=\sin (\beta) \sin (\gamma)-\cos (\beta) \cos (\gamma) \\&amp;
\sigma_6=\cos (\beta) \sin (\gamma)+\cos (\gamma) \sin
(\beta)\end{aligned}
\]</span></p>
<p>代入<span class="math inline">\(\alpha = \beta = \gamma = \epsilon =
\pi/6\)</span>验证得：</p>
<p><span class="math display">\[
\left(\begin{array}{cccc}0 &amp; \frac{\sqrt{3}}{2} &amp; \frac{1}{2}
&amp; 0 \\-1 &amp; 0 &amp; 0 &amp; 10 \\0 &amp; -\frac{1}{2} &amp;
\frac{\sqrt{3}}{2} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)
\]</span></p>
<h3 id="子空间矩阵的代数运算">子空间矩阵的代数运算</h3>
<p>然而在绘图过程中，基于einsum的绘图方式不能计算如此复杂的矩阵乘法，因此将计算结果转会python进一步处理。首先为了方便计算，在对于四个关节，均在其qlim中取出10个满足约束条件的取值，代入计算相应矩阵，得到：</p>
<p><span class="math display">\[
T_2^3(4,4,10),\ T_3^4(4,4,10),\ T_4^5(4,4,10), \ T_5^6(4,4,10)
\]</span></p>
<p>进行如下规则的矩阵乘法：<span class="math inline">\(a_{ija}\cdot
b_{jlb} =
c_{il(a*b)}\)</span>。然而这种计算方式不能使用爱因斯坦求和约定简单求和，因此牺牲部分性能，设计以下函数用于计算这种特殊的乘法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foi</span>(<span class="params">A,B</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    A:(4,4,x)</span></span><br><span class="line"><span class="string">    B:(4,4,x)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    C = np.zeros((<span class="number">4</span>,<span class="number">4</span>,np.shape(A)[<span class="number">2</span>]*np.shape(B)[<span class="number">2</span>]))</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(np.shape(A)[<span class="number">2</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(np.shape(B)[<span class="number">2</span>]):</span><br><span class="line">            C[:,:,k] = np.dot(A[:,:,i],B[:,:,j])</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<p>这种计算方式会导致计算结果出现微小的偏差，这跟python的计算方式有关。比如上述<span
class="math inline">\(\pi/6\)</span>的例子在这种计算模式下得到的结果：</p>
<p><span class="math display">\[
\begin{pmatrix}-1.94289029e-16 &amp; 8.66025404e-01 &amp; 5.00000000e-01
&amp; -8.88178420e-16 \\-1.00000000e+00 &amp; -2.14607521e-16 &amp;
0.00000000e+00 &amp; 1.00000000e+01 \\1.03585218e-16 &amp;
-5.00000000e-01 &amp; 8.66025404e-01 &amp; 4.44089210e-16
\\0.00000000e+00 &amp; 0.00000000e+00 &amp; 0.00000000e+00 &amp;
1.00000000e+00\end{pmatrix}
\]</span></p>
<p>可以看到出现了<span
class="math inline">\(10^{-16}\)</span>的误差，但这种误差是可以忽略的。</p>
<p>在这种计算模式下，将四个矩阵相乘，得到：<span
class="math inline">\(T_2^6 (4,4,10000)\)</span></p>
<h3 id="计算子空间分布">计算子空间分布</h3>
<p>按照计算规则：<span class="math inline">\(T_2^6 (4,4,10000)\cdot
\left(0,10,20,1\right) =
Op(4,10000)\)</span>，并使用第一维的前三个数字作为坐标绘制散点图，得到计算结果：</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_14.png" /></p>
<p>可以看到计算的最终结果类似于球，这可能与机械臂足够多的自由度有关。事实上，我们可以很简答的抽象出当前的结果。因为后三个关节是在同一平面内的三个转动副，我们可以认为它可以确定一个圆形的平面，圆形的半径取决于其机械臂能达到的范围。而第3个关节或者倒数第四个关节是一个过圆心的（事实上，如果不考虑杆之间的碰撞，第三个和第四个杆的连接处就是圆心）的转动副。自然而然就会形成球状的子空间分布。</p>
<p>具体的计算代码可以在补充文件中找到，相应的代码已经全部转化为python代码（包括原本使用matlab的部分），文件被命名为transformation_calculation.py，依赖于数学运算库numpy和绘图库matplotlab。</p>
<h1 id="逆运动学分析">逆运动学分析</h1>
<p>逆运动学分析是机器人学中的一个重要方向，它的目标是通过给定机器人末端执行器的位置和姿态，来求解机器人的关节参数。简单来说，就是根据机器人手臂的位置和方向来计算机器人的关节角度。</p>
<p>逆运动学的解决方案并不总是存在，也并不总是唯一的。例如，对于某些机器人，可能没有一组关节角度能够使末端执行器达到指定的位置和姿态。另一方面，对于具有冗余自由度的机器人，可能存在多个关节角度组合，都可以使末端执行器达到相同的位置和姿态。</p>
<p>逆运动学的计算通常比较复杂，可能需要使用数值方法，如迭代或优化技术。在某些特定情况下，也可能存在解析解。逆运动学在机器人路径规划、操作控制等方面具有重要应用。</p>
<h3 id="解的存在性">解的存在性</h3>
<p>我们知道，对于所有只包含转动关节和移动关节的串联型6自由度机构来说，一定是可解的，这也是我们再简化机构的过程中，以串联型为目标的简化原理。</p>
<h2 id="逆运动学分析-1">逆运动学分析</h2>
<h3 id="代数解法">代数解法</h3>
<p><strong>假设底座固定，考虑四自由度的解法。必须要注意的是，第4、5个关节本身具备<span
class="math inline">\(\pi/2\)</span>的offset，在后续的计算和绘图中，并没有考虑这些offset，但在绘图中这些是必须要注意的。</strong></p>
<p>我们先前已经计算了通用的<span
class="math inline">\(T_2^6(\alpha,\beta,\gamma,\epsilon)\)</span>，而假定我们已经得到执行坐标系的转换矩阵<span
class="math inline">\(T_{2,object}^6\)</span>。基于代数解法，存在以下方程：</p>
<p><span class="math display">\[
T_2^6(\alpha,\beta,\gamma,\epsilon) = T_{2,object}^6
\]</span></p>
<p>在前面的过程中，我们已经看到了这种计算的复杂性，对此我们不进行手动的计算。我们假设：</p>
<p><span class="math display">\[
T_{2,object}^6 = \left(\begin{array}{cccc}0 &amp; \frac{\sqrt{3}}{2}
&amp; \frac{1}{2} &amp; 0 \\-1 &amp; 0 &amp; 0 &amp; 10 \\0 &amp;
-\frac{1}{2} &amp; \frac{\sqrt{3}}{2} &amp; 0 \\0 &amp; 0 &amp; 0 &amp;
1\end{array}\right)
\]</span></p>
<p>即我们之前使用的假设，来尝试使用matlab求解，得到：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \alpha = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{\pi}{6}
\end{array}\right) \ \beta = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{5 \pi}{6}
\end{array}\right) \  \gamma = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{5 \pi}{6}
\end{array}\right) \ \varepsilon = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{5 \pi}{6}
\end{array}\right)
\end{aligned}
\]</span></p>
<p>有两组解，解得数量符合预期，两组解中，<span
class="math inline">\(\alpha\)</span>取值相同，是因为<span
class="math inline">\(\alpha\)</span>决定了所在平面。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_15.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_16.png" /></p>
<p>两组解得到了完全相同的结果。但请注意，这两幅图片的杆的顺序并不相同<span
class="math inline">\(\pi/6\)</span>的环是从当前角度看逆时针形成的，而<span
class="math inline">\(5\pi/6\)</span>的版本则是顺时针形成的。为了使这一点更加明显，我用相同的方式计算了这一组结果:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \alpha = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{\pi}{6}
\end{array}\right) \ \beta = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{2 \pi}{3}
\end{array}\right) \  \gamma = \left(\begin{array}{c}
0 \\
\pi
\end{array}\right) \ \varepsilon = \left(\begin{array}{c}
\frac{\pi}{6} \\
\frac{2 \pi}{3}
\end{array}\right)
\end{aligned}
\]</span></p>
<p>其图像如下，在这种假设下，可以很清晰的看到两者的不同。同时第一附图出现了交叉，这是不被允许的，所以这种情况可以认为有实际上的唯一解。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_17.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_18.png" /></p>
<h3 id="几何解法">几何解法</h3>
<p>在几何解法中，我们假设我们已知腕坐标系的原点坐标和工作端坐标系z轴方向，并以此进行逆动力学分析。我们依然假设<strong>底座固定，考虑四自由度的解法。</strong></p>
<p>为了方便计算，我们假设在基坐标系中，工作端坐标系的原点为：<span
class="math inline">\(\left(\begin{array}{c}
\frac{5 \sqrt{3}}{4}-\frac{15}{4} ,
\frac{5 \sqrt{3}}{2}+\frac{15}{2} ,
\frac{5 \sqrt{3}}{4}-\frac{5}{4}
\end{array}\right)\)</span>，其z轴指向<span
class="math inline">\(\left(\begin{array}{c}
\frac{1}{4} ,
-\frac{\sqrt{3}}{4} ,
\frac{\sqrt{3}}{2}
\end{array}\right)\)</span>，基座原点坐标：<span
class="math inline">\((-10,20,20)\)</span>，</p>
<p>首先正如前文所提及，能够影响后三个杆所在平面，或者说后三个转轴的垂直平面，只由第三个关键的角度<span
class="math inline">\(\alpha\)</span>影响。因此，我们一旦知道了腕z轴指向与基坐标系或者底座坐标系的z轴（事实上他们z轴重合），我们就可以很简单的求出<span
class="math inline">\(\alpha\)</span>角。</p>
<p>考虑在约定上，<span
class="math inline">\(\alpha\in[-\pi,\pi]\)</span>，得到<span
class="math inline">\(\alpha\)</span>：</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_19.png" /></p>
<p><span class="math display">\[
\alpha = \cos^{-1}\left(\frac{z_6\cdot z_1}{||z_6||\times||z_1||}\right)
= \pi/6
\]</span></p>
<p>然后我们就可以在三个轴所在的平面上解决这个三自由度的逆运动学问题。首相将所有的坐标转化为平面内的坐标，取关节4为坐标原点，原本的x方向的负方向为新的平面坐标的x方向。得到目标点在该平面内的新坐标：<span
class="math inline">\((5/2(\sqrt3-1)，5/2(-\sqrt3+1))\)</span>直接应用余弦定理得到：<span
class="math inline">\(\gamma = 0,\pi\)</span>，而<span
class="math inline">\(\varepsilon\)</span>取决于工作端坐标系z轴方向。<span
class="math inline">\(\left(\begin{array}{c}
\frac{1}{4} ,
-\frac{\sqrt{3}}{4} ,
\frac{\sqrt{3}}{2}
\end{array}\right)\)</span>向该平面投影，计算角度得到<span
class="math inline">\(\varepsilon=
\pi/6,5\pi/6\)</span>这与之前给出的结果相同。</p>
<p><span class="math display">\[
cos(\gamma) = \frac{l_1^2+l_2^2-(x^2+(y+5)^2)}{2l_1l_2} = 0
\]</span></p>
<p><span class="math display">\[
\beta = \frac{\pi-\gamma}{2}+\arctan(\frac{x}{y+5}) = \pi/6,5\pi/6
\]</span></p>
<h2
id="机器人工具箱给出的逆动力学方法">机器人工具箱给出的逆动力学方法</h2>
<blockquote>
<p>python的机器人工具箱极其——极其到从来没有见过般极其混乱，文档中所有的说明基本全部错误，我只能翻阅源代码以及查找github上与我类似的受害者和为这些受害者提供帮助的好心人的报告。</p>
</blockquote>
<p>我为程序提供的逆运动学分析原型如图右，其具体参数：q = [0, 0, pi/6,
pi/6, 0,
pi/6]，而初始姿态如图左，我会使用不同的方式进行逆运动学分析。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_20.png" /></p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_21.png" /></p>
<h3 id="levenberg-marquardt方法">Levenberg-Marquardt方法</h3>
<p>Levenberg-Marquardt方法是一种用于求解非线性最小二乘问题的优化算法，也被广泛应用于逆运动学分析。在求解逆运动学问题时，我们往往需要最小化某种误差函数，例如目标位置和机器人末端执行器实际位置之间的差距。Levenberg-Marquardt方法就是为了找到最小化这种误差的关节角度配置。</p>
<p>Levenberg-Marquardt方法结合了梯度下降法和牛顿法的思想，通过引入一个调整因子来平衡两者。当调整因子较大时，算法更接近于梯度下降法，这在误差函数的值较大时有利于快速收敛；当调整因子较小，算法更接近于牛顿法，这在误差函数的值较小时有利于精确求解。</p>
<p>在python工具箱中，通过函数以下函数可以实现计算，但必须要注意的是这个程序定义在ETS.py中，而不是DHRobot中。所以在调用时必须使用<code>robot.ets().ikine_LM</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ikine_LM</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        Tep: <span class="type">Union</span>[NDArray, SE3],</span></span><br><span class="line"><span class="params">        q0: <span class="type">Union</span>[ArrayLike, <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ilimit: <span class="built_in">int</span> = <span class="number">30</span>,</span></span><br><span class="line"><span class="params">        slimit: <span class="built_in">int</span> = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">        tol: <span class="built_in">float</span> = <span class="number">1e-6</span>,</span></span><br><span class="line"><span class="params">        mask: <span class="type">Union</span>[ArrayLike, <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        joint_limits: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        seed: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        k: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">        method: L[<span class="string">&quot;chan&quot;</span>, <span class="string">&quot;wampler&quot;</span>, <span class="string">&quot;sugihara&quot;</span>] = <span class="string">&quot;chan&quot;</span>,</span></span><br><span class="line"><span class="params">        kq: <span class="built_in">float</span> = <span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">        km: <span class="built_in">float</span> = <span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">        ps: <span class="built_in">float</span> = <span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">        pi: <span class="type">Union</span>[NDArray, <span class="built_in">float</span>] = <span class="number">0.3</span>,</span></span><br><span class="line"><span class="params">        **kwargs,</span></span><br><span class="line"><span class="params">    </span>)</span><br></pre></td></tr></table></figure>
<p>经过iterations=6930代迭代，历时8.74s，程序找到了235个可行解，并在其中选择了最小值，这个值的残差只有：4.55e-07</p>
<p>q=[2.537, 2.163, 0.5236, -0.3155, 0.9399, 0.4228]</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_22.png" /></p>
<h3 id="newton-raphson-方法">Newton-Raphson 方法</h3>
<p>牛顿-拉弗森（Newton-Raphson）方法是一种迭代法，主要用于求解非线性方程或者系统的数值解，也被广泛应用于逆运动学分析。</p>
<p>牛顿-拉弗森方法的基本思想是，对于一个非线性方程f(x)=0，我们可以在一个初始解x0附近将f(x)用泰勒级数进行展开。如果只保留到一阶项，就得到了f(x)在x0处的线性近似，解这个线性方程就可以得到一个新的解x1。然后在x1处再做一次线性近似，以此类推，通过反复迭代，可以使得解逐渐接近真实解。</p>
<p>值得注意的是，牛顿-拉弗森方法需要选择一个合适的初始解，如果初始解离真实解太远，可能会导致迭代过程难以收敛。这可能与实际应用中给出的解的质量不尽人意有关。</p>
<p>其函数本身定义与上一个方法类似，在这里不再赘述，最终计算结果，历时20.11s，进行了99979次迭代，仅给出了118的残差，并不尽人意。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_23.png" /></p>
<h1 id="速度和静力">速度和静力</h1>
<p>机器人速度和静力的研究涵盖了机器人运动学和动力学的重要部分。速度是机器人学的一个关键分支，主要研究机器人的速度、加速度以及它们与关节速度和关节加速度之间的关系。这是控制机器人精确运动的基础。静力研究，它主要涉及机器人在静止或缓慢移动时受到的力和力矩。这些力和力矩决定了机器人的稳定性和抓取能力，对于设计实现复杂操作（如搬运、装配等）的机器人来说至关重要。</p>
<h2 id="速度和角速度的传递">速度和角速度的传递</h2>
<p>为了描述关节之间的速度和角速度的传递，我们引入公式：</p>
<p><span class="math display">\[
{ }^{i+1} \omega_{i+1}={ }^{i+1} R^i \omega_i+\dot{\theta}{i+1}
\]</span></p>
<p><span class="math display">\[
{ }^i v_{i+1}={ }^i v_i+{ }^i \omega_i \times{ }^i P_{i+1}
\]</span></p>
<h2 id="角速度">角速度</h2>
<p>第一个公式描述了刚体在从坐标系 <span class="math inline">\(i\)</span>
到坐标系 <span class="math inline">\(i+1\)</span>
的变换中的角速度关系。其中， <span class="math inline">\({ }^{i+1}
\omega_{i+1}\)</span> 表示坐标系 <span
class="math inline">\(i+1\)</span> 中的角速度， <span
class="math inline">\({ }^{i+1} R^i\)</span> 表示从坐标系 <span
class="math inline">\(i\)</span> 到坐标系 <span
class="math inline">\(i+1\)</span> 的旋转矩阵， <span
class="math inline">\(\omega_i\)</span> 表示坐标系 <span
class="math inline">\(i\)</span> 中的角速度， <span
class="math inline">\(\dot{\theta}_{i+1}\)</span> <em>表示坐标系 <span
class="math inline">\(i+1\)</span> 相对于坐标系 <span
class="math inline">\(i\)</span> 的角速度变化率， <span
class="math inline">\({ }^{i+1} \hat{Z}_{i+1}^i\)</span></em>
表示从坐标系 <span class="math inline">\(i\)</span> 到坐标系 <span
class="math inline">\(i+1\)</span> 的旋转轴的单位向量。</p>
<p>以我们之前计算的从第二个关节到第三个关机的传递矩阵为例：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; T_2^3  =
&amp; \left(\begin{array}{cccc}
\cos (\alpha) &amp; -\sin (\alpha) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 10 \\
-\sin (\alpha) &amp; -\cos (\alpha) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
\end{aligned}
\]</span></p>
<p>易得，其旋转矩阵为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; R_2^3  =
&amp; \left(\begin{array}{cccc}
\cos (\alpha) &amp; -\sin (\alpha) &amp; 0  \\
0 &amp; 0 &amp; 1  \\
-\sin (\alpha) &amp; -\cos (\alpha) &amp; 0 &amp;
\end{array}\right)
\end{aligned}
\]</span></p>
<p>同时观察旋转矩阵，发现其旋转轴为原本的y轴方向，即：</p>
<p><span class="math display">\[
\hat Z_{i+1}^i = \left(\begin{array}{c}
0 \\
1 \\
0
\end{array}\right)
\]</span></p>
<p>使用python的符号计算功能，可以得到:</p>
<p><span class="math display">\[
\omega_{i+1}^i = \begin{bmatrix} \omega_{i_1}\cos(\alpha) -
\omega_{i_2}\sin(\alpha) \\ \omega_{i_3} + \dot\theta \\
-\omega_{i_1}\sin(\alpha) - \omega_{i_2}\cos(\alpha) \end{bmatrix}
\]</span></p>
<p>计算可以在rotation_calculation.py中找到</p>
<h3 id="速度">速度</h3>
<p>对于第二个公式，这个公式描述了刚体在坐标系 <span
class="math inline">\(i\)</span> 中的线速度与角速度之间的关系。其中，
<span class="math inline">\({ }^i v_{i+1}\)</span> 表示坐标系 <span
class="math inline">\(i\)</span> 中点 <span
class="math inline">\(i+1\)</span> 的线速度， <span
class="math inline">\({ }^i v_i\)</span> 表示坐标系 <span
class="math inline">\(i\)</span> 中的线速度， <span
class="math inline">\({ }^i \omega_i\)</span> 表示坐标系 <span
class="math inline">\(i\)</span>中的角速度， <span
class="math inline">\({ }^i P_{i+1}\)</span> 表示从坐标系 <span
class="math inline">\(i\)</span> 到坐标系 <span
class="math inline">\(i+1\)</span> 的位移向量。</p>
<p>根据旋转矩阵：</p>
<p><span class="math display">\[
{ }^2 P_3=\left(\begin{array}{c}0 \\10 \\0\end{array}\right)
\]</span></p>
<p>使用python的符号计算得到：</p>
<p><span class="math display">\[
v_3 = \begin{bmatrix} -10\omega_{2z} + v_{2x} \\ v_{2y} \\ 10\omega_{2x}
+ v_{2z} \end{bmatrix}
\]</span></p>
<p>计算过程可以在calculate_linear_velocity.py文件中找到。</p>
<h2 id="雅可比">雅可比</h2>
<p>在机器人运动学中，速度雅可比矩阵将关节速度的变化与末端执行器的线速度之间的关系进行了描述。它是一个
<span class="math inline">\(m \times n\)</span> 的矩阵，其中 <span
class="math inline">\(m\)</span> 是末端执行器自由度的数量 (通常是 6
，表示平移和旋转自由度)， <span class="math inline">\(n\)</span>
是机器人关节的数量。</p>
<p>速度雅可比矩阵的元素表示了末端执行器的每个自由度对于每个关节速度的影响。具体而言，速度雅可比矩阵的第
<span class="math inline">\(i\)</span> 列表示第 <span
class="math inline">\(i\)</span>
个关节速度对于末端执行器的线速度和角速度的影响。</p>
<p>一般来说，雅可比矩阵可以被表示为：</p>
<p><span class="math display">\[
\begin{bmatrix}\frac{\partial f_1}{\partial q_1} &amp; \frac{\partial
f_1}{\partial q_2} &amp; \cdots &amp; \frac{\partial f_1}{\partial q_n}
\\ \frac{\partial f_2}{\partial q_1} &amp; \frac{\partial f_2}{\partial
q_2} &amp; \cdots &amp; \frac{\partial f_2}{\partial q_n} \\ \vdots
&amp; \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial f_m}{\partial
q_1} &amp; \frac{\partial f_m}{\partial q_2} &amp; \cdots &amp;
\frac{\partial f_m}{\partial q_n} \end{bmatrix}
\]</span></p>
<p>其中，<span class="math inline">\(f_i\)</span> 表示末端执行器的第
<span class="math inline">\(i\)</span>
个自由度（例如，位置分量或旋转分量），<span
class="math inline">\(q_j\)</span> 表示第 <span
class="math inline">\(j\)</span> 个关节变量。</p>
<p>我们使用python的机器人库来计算速度雅可比。</p>
<p>根据文档，机器人库提供了两种计算雅可比矩阵的方法，分别计算Manipulator
Jacobian in end-effector frame和Manipulator Jacobian in world
frame。</p>
<p>第一种表示方法将雅可比矩阵的计算基于末端执行器的坐标系。它描述了末端执行器在自身坐标系中的速度和姿态与关节速度之间的关系。它可以用于控制末端执行器的线速度和角速度。第二种表示方法将雅可比矩阵的计算基于世界坐标系。它描述了末端执行器在世界坐标系中的速度和姿态与关节速度之间的关系。它可以用于控制末端执行器在世界坐标系中的线速度和角速度。</p>
<p>符号计算的结果过于庞大，不能再报告中展示，可以在jv_equation_0.txt和jv_equation_e.txt中分别找到。具体的计算过程可以在robot_velocity_jacobian.py中找到。</p>
<p>而数值计算的结果，在所有的关节均为初始状态时，分别为</p>
<p><span class="math display">\[
Jacob_e = \left[\begin{matrix}-1.0 &amp; 3.0 \cdot 10^{-49} &amp; 3.1
\cdot 10^{-16} &amp; 5.0 &amp; 0 &amp; 0\\\\-1.8 \cdot 10^{-16} &amp; 0
&amp; 3.8 \cdot 10^{-32} &amp; 5.0 &amp; 5.0 &amp; 0\\\\6.1 \cdot
10^{-17} &amp; 1.0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp;
1.2 \cdot 10^{-16} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1.0 &amp;
0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 6.1 \cdot 10^{-17} &amp; 1.0 &amp;
1.0 &amp; 1.0\end{matrix}\right]
\]</span></p>
<p><span class="math display">\[
Jacob_0 = \left[\begin{matrix}0 &amp; -5.5 \cdot 10^{-65} &amp; -1.9
\cdot 10^{-32} &amp; 5.0 &amp; 5.0 &amp; 0\\0 &amp; -1.0 &amp; -1.9
\cdot 10^{-32} &amp; -3.1 \cdot 10^{-16} &amp; -1.9 \cdot 10^{-32} &amp;
0\\1.0 &amp; 6.1 \cdot 10^{-17} &amp; -3.1 \cdot 10^{-16} &amp; -5.0
&amp; -9.2 \cdot 10^{-16} &amp; 0\\0 &amp; 0 &amp; -1.0 &amp; 0 &amp; 0
&amp; 0\\0 &amp; 0 &amp; -6.1 \cdot 10^{-17} &amp; -1.0 &amp; -1.0 &amp;
-1.0\\0 &amp; 0 &amp; 6.1 \cdot 10^{-17} &amp; 6.1 \cdot 10^{-17} &amp;
6.1 \cdot 10^{-17} &amp; 6.1 \cdot 10^{-17}\end{matrix}\right]
\]</span></p>
<h2 id="奇异">奇异</h2>
<p>在机器人学中，奇异点是指机器人在特定姿态下失去某些运动自由度的位置。这些特定姿态下，机器人的一个或多个关节速度可能需要无限大，才能产生末端执行器的某个期望速度，这在实际中是不可能的。奇异点的存在对于机器人的控制和操作有重要影响，需要在设计和控制机器人时予以考虑。</p>
<p>当雅可比矩阵的行列式为零时，即表示机器人处于奇异点。这是因为雅可比矩阵不可逆，无法从末端执行器速度计算出关节速度。此时，机器人在某些方向上失去运动能力，即使改变关节速度，末端执行器的速度也不会改变。</p>
<h3 id="雅可比矩阵的矩">雅可比矩阵的矩</h3>
<p>要判断一个矩阵的行列式是否为零，可以使用矩阵的秩来进行判断。矩阵的秩是指矩阵中线性无关的行或列的最大数量。如果一个矩阵的秩小于它的维度（行数或列数），则该矩阵的行列式为零。因此我们可以通过雅可比矩阵的秩来快速判断雅可比矩阵是否存在奇异点。</p>
<p>计算过程可以在robot_velocity_jacobian.py中找到。</p>
<p>经过计算，发现该雅可比矩阵的秩为5，说明这说明实际上机器人只有5个自由度。即所有空间都是奇异点。</p>
<h3 id="奇异-1">奇异</h3>
<p>然而，分析表明，由于在设计时存在三个在同一平面的轴，故在所有空间内，都有奇异点的存在。或者说对于这个设备，其实际的自由度只能达到5。</p>
<p><span class="math display">\[
det(Jacob_0) = 0
\]</span></p>
<p>这使得一般的雅可比奇异过程不能再本机构上实现，然后对于一般的机器人的雅可比分析方式依然可以在singularity_analysis.py找到，并且我提供了对另一个机器人——简单改动最后一个轴的方向的机器人的分析。在足够的时间成本下，这个程序可以给出正确的结果.</p>
<h1 id="动力学分析">动力学分析</h1>
<h2 id="质量分布">质量分布</h2>
<p>惯性张量是描述刚体对转动的惯性特性的重要量，它与刚体的质量分布和几何形状有关。</p>
<p>在给定坐标系A中，惯性张量的表示可以用一个3x3的矩阵来表示。这个矩阵被称为惯性矩阵或惯性张量矩阵。在这个表达式中，惯性矩阵被表示为一个对称矩阵，对角线上的元素分别表示刚体绕A坐标轴旋转的惯性力矩，非对角线上的元素表示刚体绕A坐标轴旋转的耦合力矩。</p>
<p><span class="math display">\[
{ }^A I=\left(\begin{array}{rrr}
I_{x x} &amp; -I_{x y} &amp; -I_{x z} \\
-I_{x y} &amp; I_{y y} &amp; -I_{y z} \\
-I_{x z} &amp; -I_{y z} &amp; I_{z z}
\end{array}\right)
\]</span></p>
<p>我通过solidwork导出了建模带来的质量分布，如列表如下:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>Mass</th>
<th>Moment Ixx</th>
<th>Moment Ixy</th>
<th>Moment Ixz</th>
<th>Moment Iyy</th>
<th>Moment Iyz</th>
<th>Moment Izz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>23.38782</td>
<td>6.425149</td>
<td>-2.20E-16</td>
<td>1.02E-16</td>
<td>1.987009</td>
<td>5.62E-10</td>
<td>4.444118</td>
</tr>
<tr class="even">
<td>9.205307</td>
<td>0.470912</td>
<td>-9.67E-19</td>
<td>2.85E-19</td>
<td>0.012207</td>
<td>-7.39E-17</td>
<td>0.466974</td>
</tr>
<tr class="odd">
<td>1.204045</td>
<td>0.000393</td>
<td>4.69E-18</td>
<td>1.27E-08</td>
<td>0.172653</td>
<td>-2.23E-19</td>
<td>0.17265</td>
</tr>
<tr class="even">
<td>0.122888</td>
<td>8.09E-05</td>
<td>-5.39E-13</td>
<td>-9.25E-20</td>
<td>7.28E-05</td>
<td>3.22E-20</td>
<td>7.17E-05</td>
</tr>
<tr class="odd">
<td>1.139717</td>
<td>0.000433</td>
<td>-2.97E-05</td>
<td>3.49E-09</td>
<td>0.029837</td>
<td>-1.09E-09</td>
<td>0.029969</td>
</tr>
<tr class="even">
<td>0.580515</td>
<td>0.012522</td>
<td>-2.17E-19</td>
<td>-5.60E-17</td>
<td>0.012507</td>
<td>-6.07E-17</td>
<td>0.000275</td>
</tr>
<tr class="odd">
<td>0.523966</td>
<td>0.00016</td>
<td>6.17E-05</td>
<td>1.32E-17</td>
<td>0.009611</td>
<td>1.90E-19</td>
<td>0.009736</td>
</tr>
<tr class="even">
<td>0.583844</td>
<td>0.00244</td>
<td>2.40E-18</td>
<td>-1.84E-18</td>
<td>0.001474</td>
<td>0.000566</td>
<td>0.00113</td>
</tr>
</tbody>
</table>
<p>在程序中添加了质量分布信息的程序可以在Mass_Inertia_Setter.py中找到</p>
<h2 id="动力学分析-1">动力学分析</h2>
<blockquote>
<p>在质量信息的基础上，可以进行多样的逆动力学分析方法</p>
</blockquote>
<h3 id="逆动力学-递归牛顿欧拉算法">逆动力学-递归牛顿欧拉算法</h3>
<p>逆动力学是机器人学中的一个重要概念，用于计算机器人在给定关节状态下的关节力和力矩。正向动力学是根据已知的关节力和力矩来计算机器人的运动状态（位置、速度和加速度），而逆动力学则是相反的过程。</p>
<p>逆动力学的计算过程可以通过递归牛顿欧拉算法来实现。该算法从机器人的末端开始，递归地向前和向后传递力和力矩，从而计算出每个关节的力和力矩。递归牛顿欧拉算法利用了牛顿定律和欧拉方程，考虑了机器人的质量、惯性和外部力矩等因素。</p>
<p>相应的代码可以在Mass_Inertia_Setter.py中找到</p>
<p>以下是一些计算结果:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>关节位置</th>
<th>关节速度</th>
<th>关节加速度</th>
<th>力和力矩-[F_x F_y F_z M_x M_y M_z]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[ 3.49631265e+02 7.35992828e-15 -8.95879068e-15 -8.43773796e+01</td>
</tr>
<tr class="even">
<td>-5.23063684e-15 0.00000000e+00]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td>[20, 10, pi/3, pi/3, pi/3, pi/3]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[ 3.49631265e+02 7.35992828e-15 -8.95879068e-15 -8.43773796e+01</td>
</tr>
<tr class="even">
<td>-5.23063684e-15 0.00000000e+00]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>[20, 10, pi/3, pi/3, pi/3, pi/3]</td>
<td>[1, 1, 1, 1, 1, 1]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[ 347.58516689 -250.71837502 21.69095014 -0.91517928
51.59007257</td>
</tr>
<tr class="even">
<td>0. ]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>[20, 10, pi/3, pi/3, pi/3, pi/3]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[1, 1, 1, 1, 1, 1]</td>
<td>[347.20775265 42.27251513 -34.89286925 164.60759118 -16.2169242</td>
</tr>
<tr class="even">
<td>0. ]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>通过第1 2 组，可以看到由于没有考虑重力，关节位置并不影响受力</li>
<li>通过第3 4组可以看到速度和加速度对系统的影响</li>
</ul>
<h3 id="关节加速度">关节加速度</h3>
<p><code>accel</code>函数基于逆动力学算法，通过求解动力学方程来计算关节加速度。它考虑了机器人的质量、惯性、连杆参数以及外部力矩的影响。通过使用这个函数，您可以获得机器人在给定关节状态下的加速度信息，从而了解机器人的动力学行为。</p>
<p>然而这触发了由于机器人模型的质量和惯性参数设置不正确导致的异常。这意味着机器人模型的质量和惯性参数无法形成非奇异（非可逆）的惯性矩阵。由于所有的质量信息均由solidwork提供，这是无法解决的。为了继续实验，我使用了Puma560模型进一步实验。</p>
<p>程序可以在puma_exemple.py找到。</p>
<p><img
src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/post%2Frobot-1%2FUntitled_24.png" /></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Joint coordinates</th>
<th>Joint velocity</th>
<th>Joint torques of the robot</th>
<th>acceleration due to applied torque</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[ 0.04708838 -8.53721878 4.18541175 5.195206 5.88407268
5.15078362]</td>
</tr>
<tr class="even">
<td>2</td>
<td>[20, 10, pi/3, pi/3, pi/3, pi/3]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[-0.46352559 6.19172614 -8.48784377 5.26388791 5.83647604 5.1517202
]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[1, 1, 1, 1, 1, 1]</td>
<td>[ -7.67330515 -12.81640524 -7.87297484 -1.30315941 -0.35232642</td>
</tr>
<tr class="even">
<td>2.4773214 ]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[1, 1, 1, 1, 1, 1]</td>
<td>[0, 0, 0, 0, 0, 0]</td>
<td>[-2.46226150e-01 -8.68293024e+00 3.14620807e+00 2.09846469e-03</td>
</tr>
<tr class="even">
<td>6.03123947e-02 5.03085045e-05]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="总结">总结</h1>
<p>本报告总结了针对武器炮塔装置的机械臂模型的设计和目标。我详细描述了solidwork模型的各个部分及其功能，包括基座、横杆、底座和连杆等。然后，我简化了模型，并使用改进的Denavit-Hartenberg方法重新建立了模型。这一过程包括定义各关节的坐标系，确定原点位置和z轴方向，分析连杆参数，并在Python中进行建模。我对模型进行了运动学分析，计算了机器人手臂的位置和方向。</p>
<p>我还讨论了机器人的运动学分析，包括正向运动学和逆向运动学。正向运动学是根据机器人的关节参数确定其末端执行器位置和姿态的过程。我通过设定关节角度并计算变换矩阵，得到了机器人的正向运动学模型。使用Python的Robotics
Toolbox工具箱计算了机器人的正向运动学，验证了之前的分析和计算结果。我还讨论了操作臂子空间，即机器人操作臂在所有可能的关节配置下能够到达的空间区域。操作臂子空间的大小和形状取决于机器人的几何结构，包括关节的数量、类型和排列方式。通过设定关节角度并计算矩阵，我得到了操作臂的子空间矩阵，并对运算过程中的微小偏差进行了讨论。</p>
<p>逆运动学分析是根据机器人末端执行器的位置和姿态计算机器人的关节参数。我使用代数解法和几何解法对逆运动学进行了深入探讨，并尝试了Levenberg-Marquardt方法和Newton-Raphson方法。</p>
<p>我还讨论了机器人的速度和静力学。速度部分介绍了描述关节之间速度和角速度传递的公式，并讨论了速度雅可比矩阵。静力学部分研究了机器人在静止或缓慢移动时受到的力和力矩，这对于设计实现复杂操作的机器人非常重要。我还讨论了机器人学中的奇异点，即机器人在特定姿态下失去某些运动自由度的位置。</p>
<p>最后，我分析了机器人的动力学行为。通过Solidwork导出的质量分布信息和递归牛顿欧拉算法，计算了逆动力学和关节力和力矩。我还使用accel函数计算了关节加速度。</p>
<p>综上所述，本文对武器炮塔装置的机械臂模型进行了设计和分析，并在运动学、逆运动学、速度和静力学以及动力学等方面进行了探讨。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://raphaelhyaan.cn">Raphael Hyaan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://raphaelhyaan.cn/2023/11/08/others/robot-1/">http://raphaelhyaan.cn/2023/11/08/others/robot-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://raphaelhyaan.cn" target="_blank">Raphael's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/">零散笔记</a><a class="post-meta__tags" href="/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/">大作业</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/18/physique/EM/" title="电磁辐射波课程总览"><img class="cover" src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Fcover%2F%E7%94%B5%E7%A3%81%E5%AD%A6.png" onerror="onerror=null;src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">电磁辐射波课程总览</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/08/physique/ms/rdm-4/" title="RDM Chapitre 4 能量方法 Méthodes Energétiques"><img class="cover" src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fstructure.png" onerror="onerror=null;src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RDM Chapitre 4 能量方法 Méthodes Energétiques</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2FR-2.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffriend_404.gif'" alt="avatar"/></div><div class="author-info__name">Raphael Hyaan</div><div class="author-info__description">何日可谓归去来</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/raphaelhyaan"><i class="fab fa-github"></i><span>Bonjour</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/raphaelhyaan" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:raphael.ma.yuhan@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">仰观宇宙之大，俯察品类之盛</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">机器人课程报告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">背景介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B"><span class="toc-number">3.</span> <span class="toc-text">模型建立</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">模型的描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">模型简化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#robotics-toolbox-for-python-rtb"><span class="toc-number">3.1.1.</span> <span class="toc-text">Robotics Toolbox for Python
(rtb)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8C%96-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">模型简化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">运动学分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">4.1.</span> <span class="toc-text">运动学分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%87%82%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.</span> <span class="toc-text">操作臂子空间描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.0.1.</span> <span class="toc-text">子空间的符号表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A9%BA%E9%97%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">5.0.2.</span> <span class="toc-text">子空间矩阵的代数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%90%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="toc-number">5.0.3.</span> <span class="toc-text">计算子空间分布</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">逆运动学分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%9A%84%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="toc-number">6.0.1.</span> <span class="toc-text">解的存在性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">6.1.</span> <span class="toc-text">逆运动学分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E8%A7%A3%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">代数解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E8%A7%A3%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">几何解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%BB%99%E5%87%BA%E7%9A%84%E9%80%86%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">机器人工具箱给出的逆动力学方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#levenberg-marquardt%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">Levenberg-Marquardt方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-raphson-%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">Newton-Raphson 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%99%E5%8A%9B"><span class="toc-number">7.</span> <span class="toc-text">速度和静力</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E5%92%8C%E8%A7%92%E9%80%9F%E5%BA%A6%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">7.1.</span> <span class="toc-text">速度和角速度的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%92%E9%80%9F%E5%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text">角速度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6"><span class="toc-number">7.2.1.</span> <span class="toc-text">速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%85%E5%8F%AF%E6%AF%94"><span class="toc-number">7.3.</span> <span class="toc-text">雅可比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%BC%82"><span class="toc-number">7.4.</span> <span class="toc-text">奇异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9F%A9"><span class="toc-number">7.4.1.</span> <span class="toc-text">雅可比矩阵的矩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%BC%82-1"><span class="toc-number">7.4.2.</span> <span class="toc-text">奇异</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">动力学分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%88%86%E5%B8%83"><span class="toc-number">8.1.</span> <span class="toc-text">质量分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">8.2.</span> <span class="toc-text">动力学分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8A%A8%E5%8A%9B%E5%AD%A6-%E9%80%92%E5%BD%92%E7%89%9B%E9%A1%BF%E6%AC%A7%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">逆动力学-递归牛顿欧拉算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%8A%82%E5%8A%A0%E9%80%9F%E5%BA%A6"><span class="toc-number">8.2.2.</span> <span class="toc-text">关节加速度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/21/novel-Le-Prisonnier-du-Vatican/" title="梵蒂冈之囚"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2F奥蕊莉亚.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="梵蒂冈之囚"/></a><div class="content"><a class="title" href="/2025/10/21/novel-Le-Prisonnier-du-Vatican/" title="梵蒂冈之囚">梵蒂冈之囚</a><time datetime="2025-10-20T17:29:55.000Z" title="发表于 2025-10-21 01:29:55">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/04/RH-FASTMNMF/" title="FastMNMF及改进"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fpink01-s.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="FastMNMF及改进"/></a><div class="content"><a class="title" href="/2025/08/04/RH-FASTMNMF/" title="FastMNMF及改进">FastMNMF及改进</a><time datetime="2025-08-04T14:59:12.000Z" title="发表于 2025-08-04 22:59:12">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/04/RH-BF/" title="波束形成"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fpink01-s.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="波束形成"/></a><div class="content"><a class="title" href="/2025/08/04/RH-BF/" title="波束形成">波束形成</a><time datetime="2025-08-04T14:59:11.000Z" title="发表于 2025-08-04 22:59:11">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/snake-1/" title="从北京的四种毒蛇开始"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2Fsnake-1.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="从北京的四种毒蛇开始"/></a><div class="content"><a class="title" href="/2025/06/30/snake-1/" title="从北京的四种毒蛇开始">从北京的四种毒蛇开始</a><time datetime="2025-06-30T14:22:54.000Z" title="发表于 2025-06-30 22:22:54">2025-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/RH-NMF/" title="NMF及语音分离"><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ftop_image%2FR-a.png" onerror="this.onerror=null;this.src='https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2Ffavicon.png'" alt="NMF及语音分离"/></a><div class="content"><a class="title" href="/2025/06/30/RH-NMF/" title="NMF及语音分离">NMF及语音分离</a><time datetime="2025-06-30T13:30:25.000Z" title="发表于 2025-06-30 21:30:25">2025-06-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Raphael Hyaan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><span>备案号: </span><a href="href=&quot;https://beian.miit.gov.cn/&quot; ">京ICP备2024051904号</a><span class="footer-separator">|</span><img src="https://raphaelhyaan-1322456377.cos.ap-beijing.myqcloud.com/source%2F%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt="MIT License" height="20" align="top"/><span> </span><a href="href=&quot;https://beian.mps.gov.cn/#/query/webSearch?code=11010802044068&quot; ">京公网安备11010802044068号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>